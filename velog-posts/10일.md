<h1 id="제네릭generic">제네릭(Generic)</h1>
<ul>
<li>자바에서 제공하는 다양한 종류의 클래스와 인터페이스를 내부멤버에서 활용하는 클래스를 작성할때</li>
<li>동일한 이름의 메서드가 다양한 타입의 입력매개변수를 가질수있도록할때</li>
<li>사용하는 문법요소</li>
</ul>
<h2 id="제네릭문법">제네릭문법</h2>
<ul>
<li>제네릭클래스, 인터페이스 정의<pre><code class="language-java">접근지정자 class 클래스명&lt;T&gt; {}
</code></pre>
</li>
</ul>
<p>접근지정자 interface 클래스명 {}</p>
<pre><code>
### 제네릭클래스의 객체생성
- 클래스를 정의하는 시점에 타입을 지정하는 것이 아니라 객체를 생성하는 시점에 타입지정
```java
클래스명&lt;실제제네릭타입&gt; 참조변수명 = new 클래스명&lt;실제제네릭타입&gt;();
//또는
클래스명&lt;실제제네릭타입&gt; 참조변수명 = new 클래스명&lt;&gt;();</code></pre><h2 id="제네릭메서드">제네릭메서드</h2>
<h3 id="제네릭메서드의-정의와-호출">제네릭메서드의 정의와 호출</h3>
<ul>
<li>제네릭메서드는 호출되는 시점에 실제 제네릭타입지정<pre><code class="language-java">접근지정자 &lt;T&gt; T 메서드명 (T t) {}
//리턴타입과 매개변수는 제네릭타입이 오지않을 수 있음)</code></pre>
</li>
<li>제네릭메서드 호출의 문법구조<pre><code class="language-java">참조객체.&lt;실제제네릭타입&gt;메서드명(입력매개변수);
//입력매개변수를 통해 제네릭타입을 추론할수 있을때는 &lt;실제제네릭타입&gt; 생략가능</code></pre>
</li>
</ul>
<h3 id="제네릭메서드-내에서-사용할-수-있는-메서드">제네릭메서드 내에서 사용할 수 있는 메서드</h3>
<ul>
<li>제네릭메서드의 제네릭타입변수는 메서드가 호출되는 시점에 결정되므로</li>
<li>제네릭메서드를 정의하는 시점에는 어떤타입이 입력될지 모름</li>
<li>따라서 특정타입에 포함돼있는 메서드(String 객체의 length() 등)는 메서드를 정의하는시점에 사용할수 없음</li>
<li>아직 결정되지않은 제네릭타입 객체는 Object타입이라고 할 수 있음(모든 클래스는 Object클래스의 자식클래스이기때문)</li>
<li>따라서 제네릭메서드의 내부에는 아직 확징되지않은 제네릭타입객체의 멤버중 Object에서 물려받은 메서드만 사용할 수 있음)</li>
<li>즉, 나중에 어떤 타입이 제네릭변수로 확정되더라도 항상 사용할 수 있는 메서드만 제네릭메서드내부에서 사용가능</li>
</ul>
<h2 id="제네릭타입범위제한">제네릭타입범위제한</h2>
<h3 id="제네릭타입범위제한의-필요성">제네릭타입범위제한의 필요성</h3>
<ul>
<li>특정타입만 저장 및 관리하는 제네릭클래스를 생성하고싶다면 제네릭타입으로 올 수 있는 실제타입의 종류를 제한해야함</li>
<li>이것을 '제네릭타입의 범위제한(bound)'라고함</li>
<li>제네릭타입범위를 제한하면 입력매개변수로 제네릭타입또는 타입의 자식클래스만 대입할 수 있고,</li>
<li>제네릭타입변수를 받는 메서드는 제한된타입객체의 메서드를 사용할 수 있게됨</li>
</ul>
<h3 id="제네릭타입범위제한의-종류와-타입범위제한방법">제네릭타입범위제한의 종류와 타입범위제한방법</h3>
<ul>
<li>제네릭클래스, 제네릭메서드, 제네릭타입을 입력매개변수로갖는 일반메서드를 <strong>정의하는 과정에서 제네릭타입의 범위를 제한함</strong></li>
</ul>
<h4 id="제네릭클래스의-타입제한">제네릭클래스의 타입제한</h4>
<ul>
<li>제네릭 클래스의 정의과정에서 제네릭타입을 제한하는 방법은 <code>&lt;제네릭타입변수 extends 상위클래스&gt;</code>와 같이 제네릭타입으로 대입될수있는 최상위클래스를 extends키워드와 함께 정의하는 것임</li>
<li>제네릭클래스타입제한문법구조<pre><code class="language-java">접근지정자 class 클래스명 &lt;T extends 최상위클래스/인터페이스명&gt; {}
//클래스/인터페이스 상관없이 항상 extends사용</code></pre>
</li>
<li>여기서 사용한 extends키워드는 상속과 달리 '최상위 클래스/인터페이스로 지정한다'는 의미</li>
</ul>
<p>📌제네릭타입생략하고 재네릭객체생성</p>
<ul>
<li>제네릭클래스의 객체를 생성할때 제네릭타입을 생략하면 최상위클래스가 입력된 것으로 간주함<pre><code class="language-java">class D&lt;T extends B&gt; {
  private T t;
  public T get() {return t;}
  public void set(T t) {this.t = t'}
}</code></pre>
</li>
<li>여기서 클래스D는 <code>&lt;T extends B&gt;</code>를 이용해 최상위클래스를 B로 제한함</li>
<li>이때 <code>D d = new D();</code>와 같이 제네릭타입을 생략하면 최상위클래스인 <code>&lt;B&gt;</code>타입이 제네릭타입으로 대입된 것으로 간주</li>
<li><code>D&lt;B&gt; d = new D&lt;&gt;();</code>와 동일의미</li>
</ul>
<h4 id="제네릭메서드의-타입제한">제네릭메서드의 타입제한</h4>
<ul>
<li><p>제네릭클래스와 마찬가지로 <code>&lt;제네릭타입변수 extends 상위클래스&gt;</code>와 같이 올수있는 최상위 타입을 정의하고,</p>
</li>
<li><p>클래스와 인터페이스 모두 extends 키워드 사용</p>
</li>
<li><p>제네릭메서드의 타입제한문법구조</p>
<pre><code class="language-java">접근지정자 &lt;T extends 최상위 클래스/인터페이스명&gt; T 메서드명(T t) {
  //최상위 클래스의 메서드 사용가능
}</code></pre>
</li>
</ul>
<h4 id="메서드매개변수일때-제네릭클래스의-타입제한">메서드매개변수일때 제네릭클래스의 타입제한</h4>
<ul>
<li>제네릭클래스타입변수가 일반메서드의 입력매개변수로 사용될때는 제네릭클래스객체의 제네릭타입은 크게 4가지 형태로 제한함</li>
</ul>
<p>📌제네릭클래스객체의 제네릭타입</p>
<pre><code class="language-java">리턴타입 메서드명(제네릭클래스명&lt;제네릭타입명&gt; 참조변수명) {}</code></pre>
<ul>
<li>객체의 제네릭타입을 특정타입으로 확정</li>
<li>이때 해당타입을 제네릭타입으로 갖는 제네릭객체만 입력매개변수로 전달가능<pre><code class="language-java">리턴타입 메서드명(제네릭클래스명&lt;?&gt; 참조변수명) {}</code></pre>
</li>
<li><code>&lt;?&gt;</code>에는 제네릭타입으로 어떤것이 대입되든 해당제네릭객체이기만하면 매개변수로 사용가능<pre><code class="language-java">리턴타입 메서드명(제네릭클래스명&lt;? extends 상위클래스/인터페이스&gt; 참조변수명) {}</code></pre>
</li>
<li>상위클래스 또는 상위클래스의 자식클래스타입이 제네릭타입으로 대입된 객체가 매개변수로 올 수 있음<pre><code class="language-java">리턴타입 메서드명(제네릭클래스명&lt;? super 하위클래스/인터페이스&gt; 참조변수명) {}</code></pre>
</li>
<li>extends와 반대개념으로 제네릭타입으로 하위클래스 또는 하위클래스의 부모클래스타입이 올 수 있음</li>
</ul>